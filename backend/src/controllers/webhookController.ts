import { Request, Response } from 'express';
import crypto from 'crypto';
import { webhookService } from '../services/webhookService';
import { Message, Platform } from '../types';

/**
 * Base webhook controller with common functionality
 */
export class WebhookController {
  /**
   * Handle Telegram webhook
   */
  async handleTelegramWebhook(req: Request, res: Response): Promise<void> {
    try {
      const payload = req.body;
      const signature = req.headers['x-telegram-bot-api-secret-token'] as string;
      const secret = process.env.TELEGRAM_WEBHOOK_SECRET || '';

      // Verify signature
      if (!webhookService.verifyTelegramSignature(JSON.stringify(payload), signature, secret)) {
        res.status(401).json({ error: 'Invalid signature' });
        return;
      }

      // Validate payload
      if (!webhookService.validatePayload(payload, ['message'])) {
        res.status(400).json({ error: 'Invalid payload structure' });
        return;
      }

      // Parse Telegram message
      const telegramMessage = payload.message;
      const chatId = telegramMessage.chat.id.toString();
      
      // Find connected account by platform user ID (chat ID)
      const account = await this.findAccountByPlatformUserId('telegram', chatId);
      
      if (!account) {
        console.warn(`No connected account found for Telegram chat ${chatId}`);
        res.status(200).json({ ok: true }); // Still return 200 to avoid retries
        return;
      }

      // Transform to our message format
      const messageData: Message = {
        id: '', // Will be generated by database
        conversationId: chatId,
        platformMessageId: telegramMessage.message_id.toString(),
        senderId: telegramMessage.from.id.toString(),
        senderName: telegramMessage.from.username || telegramMessage.from.first_name || 'Unknown',
        content: telegramMessage.text || telegramMessage.caption || '',
        messageType: this.getTelegramMessageType(telegramMessage),
        mediaUrl: this.getTelegramMediaUrl(telegramMessage),
        isOutgoing: false,
        isRead: false,
        sentAt: new Date(telegramMessage.date * 1000),
        createdAt: new Date()
      };

      // Process the message
      await webhookService.processIncomingMessage(
        account.id,
        messageData,
        'telegram',
        req.body
      );

      res.status(200).json({ ok: true });
    } catch (error) {
      webhookService.logWebhookFailure('telegram', error as Error, req.body);
      res.status(500).json({ error: 'Internal server error' });
    }
  }

  /**
   * Handle Twitter/X webhook
   */
  async handleTwitterWebhook(req: Request, res: Response): Promise<void> {
    try {
      const payload = JSON.stringify(req.body);
      const signature = req.headers['x-twitter-webhooks-signature'] as string;
      const secret = process.env.TWITTER_CONSUMER_SECRET || '';

      // Verify signature
      if (!webhookService.verifyTwitterSignature(payload, signature, secret)) {
        res.status(401).json({ error: 'Invalid signature' });
        return;
      }

      const body = req.body;

      // Handle CRC challenge
      if (req.query.crc_token) {
        const crcToken = req.query.crc_token as string;
        const responseToken = crypto
          .createHmac('sha256', secret)
          .update(crcToken)
          .digest('base64');
        res.status(200).json({ response_token: `sha256=${responseToken}` });
        return;
      }

      // Validate payload
      if (!webhookService.validatePayload(body, ['direct_message_events'])) {
        res.status(400).json({ error: 'Invalid payload structure' });
        return;
      }

      // Process each DM event
      for (const dmEvent of body.direct_message_events) {
        const senderId = dmEvent.message_create.sender_id;
        const recipientId = dmEvent.message_create.target.recipient_id;
        
        // Find connected account
        const account = await this.findAccountByPlatformUserId('twitter', recipientId);
        
        if (!account) {
          console.warn(`No connected account found for Twitter user ${recipientId}`);
          continue;
        }

        // Transform to our message format
        const messageData: Message = {
          id: '',
          conversationId: senderId, // Use sender ID as conversation ID
          platformMessageId: dmEvent.id,
          senderId: senderId,
          senderName: body.users?.[senderId]?.screen_name || 'Unknown',
          content: dmEvent.message_create.message_data.text,
          messageType: 'text',
          isOutgoing: false,
          isRead: false,
          sentAt: new Date(parseInt(dmEvent.created_timestamp)),
          createdAt: new Date()
        };

        await webhookService.processIncomingMessage(
          account.id,
          messageData,
          'twitter',
          req.body
        );
      }

      res.status(200).json({ ok: true });
    } catch (error) {
      webhookService.logWebhookFailure('twitter', error as Error, req.body);
      res.status(500).json({ error: 'Internal server error' });
    }
  }

  /**
   * Handle LinkedIn webhook
   */
  async handleLinkedInWebhook(req: Request, res: Response): Promise<void> {
    try {
      const payload = JSON.stringify(req.body);
      const signature = req.headers['x-li-signature'] as string;
      const secret = process.env.LINKEDIN_CLIENT_SECRET || '';

      // Verify signature
      if (!webhookService.verifyLinkedInSignature(payload, signature, secret)) {
        res.status(401).json({ error: 'Invalid signature' });
        return;
      }

      const body = req.body;

      // Validate payload
      if (!webhookService.validatePayload(body, ['eventType', 'data'])) {
        res.status(400).json({ error: 'Invalid payload structure' });
        return;
      }

      // Only process message events
      if (body.eventType !== 'MESSAGE_EVENT') {
        res.status(200).json({ ok: true });
        return;
      }

      const messageEvent = body.data;
      const conversationId = messageEvent.conversationId;
      const senderId = messageEvent.from;

      // Find connected account
      const account = await this.findAccountByPlatformUserId('linkedin', messageEvent.recipient);
      
      if (!account) {
        console.warn(`No connected account found for LinkedIn user ${messageEvent.recipient}`);
        res.status(200).json({ ok: true });
        return;
      }

      // Transform to our message format
      const messageData: Message = {
        id: '',
        conversationId: conversationId,
        platformMessageId: messageEvent.messageId,
        senderId: senderId,
        senderName: 'LinkedIn User', // LinkedIn doesn't provide name in webhook
        content: messageEvent.text,
        messageType: 'text',
        isOutgoing: false,
        isRead: false,
        sentAt: new Date(messageEvent.createdAt),
        createdAt: new Date()
      };

      await webhookService.processIncomingMessage(
        account.id,
        messageData,
        'linkedin',
        req.body
      );

      res.status(200).json({ ok: true });
    } catch (error) {
      webhookService.logWebhookFailure('linkedin', error as Error, req.body);
      res.status(500).json({ error: 'Internal server error' });
    }
  }

  /**
   * Handle Instagram webhook
   */
  async handleInstagramWebhook(req: Request, res: Response): Promise<void> {
    try {
      // Handle verification challenge
      if (req.query['hub.mode'] === 'subscribe' && req.query['hub.verify_token']) {
        const verifyToken = 'instagram_verify_token_123'; // Hardcoded for now
        console.log('[instagram-webhook] Verification request:', req.query);
        if (req.query['hub.verify_token'] === verifyToken) {
          console.log('[instagram-webhook] Verification successful');
          res.status(200).send(req.query['hub.challenge']);
          return;
        } else {
          console.log('[instagram-webhook] Verification failed - token mismatch');
          res.status(403).json({ error: 'Invalid verify token' });
          return;
        }
      }

      const payload = JSON.stringify(req.body);
      const signature = req.headers['x-hub-signature-256'] as string;
      const appSecret = process.env.FACEBOOK_APP_SECRET || '';

      // Verify signature
      if (!webhookService.verifyFacebookSignature(payload, signature, appSecret)) {
        res.status(401).json({ error: 'Invalid signature' });
        return;
      }

      const body = req.body;

      // Process entries
      if (body.object === 'instagram' && body.entry) {
        for (const entry of body.entry) {
          if (entry.messaging) {
            for (const messagingEvent of entry.messaging) {
              await this.processInstagramMessage(messagingEvent);
            }
          }
        }
      }

      res.status(200).json({ ok: true });
    } catch (error) {
      webhookService.logWebhookFailure('instagram', error as Error, req.body);
      res.status(500).json({ error: 'Internal server error' });
    }
  }

  /**
   * Handle WhatsApp webhook
   */
  async handleWhatsAppWebhook(req: Request, res: Response): Promise<void> {
    try {
      // Handle verification challenge
      if (req.query['hub.mode'] === 'subscribe' && req.query['hub.verify_token']) {
        const verifyToken = process.env.WHATSAPP_VERIFY_TOKEN || '';
        if (req.query['hub.verify_token'] === verifyToken) {
          res.status(200).send(req.query['hub.challenge']);
          return;
        } else {
          res.status(403).json({ error: 'Invalid verify token' });
          return;
        }
      }

      const payload = JSON.stringify(req.body);
      const signature = req.headers['x-hub-signature-256'] as string;
      const appSecret = process.env.FACEBOOK_APP_SECRET || '';

      // Verify signature
      if (!webhookService.verifyFacebookSignature(payload, signature, appSecret)) {
        res.status(401).json({ error: 'Invalid signature' });
        return;
      }

      const body = req.body;

      // Process entries
      if (body.object === 'whatsapp_business_account' && body.entry) {
        for (const entry of body.entry) {
          if (entry.changes) {
            for (const change of entry.changes) {
              if (change.value?.messages) {
                for (const message of change.value.messages) {
                  await this.processWhatsAppMessage(message, change.value.metadata);
                }
              }
            }
          }
        }
      }

      res.status(200).json({ ok: true });
    } catch (error) {
      webhookService.logWebhookFailure('whatsapp', error as Error, req.body);
      res.status(500).json({ error: 'Internal server error' });
    }
  }

  /**
   * Handle Facebook Pages webhook
   */
  async handleFacebookWebhook(req: Request, res: Response): Promise<void> {
    try {
      // Handle verification challenge
      if (req.query['hub.mode'] === 'subscribe' && req.query['hub.verify_token']) {
        const verifyToken = process.env.FACEBOOK_VERIFY_TOKEN || '';
        if (req.query['hub.verify_token'] === verifyToken) {
          res.status(200).send(req.query['hub.challenge']);
          return;
        } else {
          res.status(403).json({ error: 'Invalid verify token' });
          return;
        }
      }

      const payload = JSON.stringify(req.body);
      const signature = req.headers['x-hub-signature-256'] as string;
      const appSecret = process.env.FACEBOOK_APP_SECRET || '';

      // Verify signature
      if (!webhookService.verifyFacebookSignature(payload, signature, appSecret)) {
        res.status(401).json({ error: 'Invalid signature' });
        return;
      }

      const body = req.body;

      // Process entries
      if (body.object === 'page' && body.entry) {
        for (const entry of body.entry) {
          if (entry.messaging) {
            for (const messagingEvent of entry.messaging) {
              await this.processFacebookMessage(messagingEvent);
            }
          }
        }
      }

      res.status(200).json({ ok: true });
    } catch (error) {
      webhookService.logWebhookFailure('facebook', error as Error, req.body);
      res.status(500).json({ error: 'Internal server error' });
    }
  }

  /**
   * Handle Microsoft Teams webhook
   */
  async handleTeamsWebhook(req: Request, res: Response): Promise<void> {
    try {
      const authHeader = req.headers.authorization;
      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        res.status(401).json({ error: 'Missing or invalid authorization header' });
        return;
      }

      const token = authHeader.substring(7);
      const appId = process.env.TEAMS_APP_ID || '';

      // Verify JWT token
      if (!webhookService.verifyTeamsSignature(token, appId)) {
        res.status(401).json({ error: 'Invalid token' });
        return;
      }

      const body = req.body;

      // Handle validation request
      if (body.validationToken) {
        res.status(200).send(body.validationToken);
        return;
      }

      // Process notification
      if (body.value && Array.isArray(body.value)) {
        for (const notification of body.value) {
          if (notification.resourceData) {
            await this.processTeamsMessage(notification.resourceData);
          }
        }
      }

      res.status(202).json({ ok: true });
    } catch (error) {
      webhookService.logWebhookFailure('teams', error as Error, req.body);
      res.status(500).json({ error: 'Internal server error' });
    }
  }

  // Helper methods

  private async findAccountByPlatformUserId(platform: Platform, platformUserId: string) {
    const { queryOne } = await import('../db/queryHelpers');
    return queryOne(
      `SELECT * FROM connected_accounts 
       WHERE platform = $1 AND platform_user_id = $2 AND is_active = true`,
      [platform, platformUserId]
    );
  }

  private getTelegramMessageType(message: any): 'text' | 'image' | 'video' | 'file' {
    if (message.photo) return 'image';
    if (message.video) return 'video';
    if (message.document) return 'file';
    return 'text';
  }

  private getTelegramMediaUrl(message: any): string | undefined {
    if (message.photo) {
      // Get the largest photo
      const photos = message.photo;
      return photos[photos.length - 1]?.file_id;
    }
    if (message.video) return message.video.file_id;
    if (message.document) return message.document.file_id;
    return undefined;
  }

  private async processInstagramMessage(messagingEvent: any): Promise<void> {
    const senderId = messagingEvent.sender.id;
    const recipientId = messagingEvent.recipient.id;
    const message = messagingEvent.message;

    if (!message) return;

    // Find connected account
    const account = await this.findAccountByPlatformUserId('instagram', recipientId);
    
    if (!account) {
      console.warn(`No connected account found for Instagram user ${recipientId}`);
      return;
    }

    // Transform to our message format
    const messageData: Message = {
      id: '',
      conversationId: senderId,
      platformMessageId: message.mid,
      senderId: senderId,
      senderName: 'Instagram User',
      content: message.text || '',
      messageType: message.attachments?.[0]?.type || 'text',
      mediaUrl: message.attachments?.[0]?.payload?.url,
      isOutgoing: false,
      isRead: false,
      sentAt: new Date(messagingEvent.timestamp),
      createdAt: new Date()
    };

    await webhookService.processIncomingMessage(
      account.id,
      messageData,
      'instagram',
      { messagingEvent }
    );
  }

  private async processWhatsAppMessage(message: any, metadata: any): Promise<void> {
    const phoneNumberId = metadata.phone_number_id;
    const senderId = message.from;

    // Find connected account by phone number ID
    const account = await this.findAccountByPlatformUserId('whatsapp', phoneNumberId);
    
    if (!account) {
      console.warn(`No connected account found for WhatsApp phone ${phoneNumberId}`);
      return;
    }

    // Transform to our message format
    const messageData: Message = {
      id: '',
      conversationId: senderId,
      platformMessageId: message.id,
      senderId: senderId,
      senderName: message.profile?.name || 'WhatsApp User',
      content: message.text?.body || message.caption || '',
      messageType: message.type === 'text' ? 'text' : message.type,
      mediaUrl: message.image?.id || message.video?.id || message.document?.id,
      isOutgoing: false,
      isRead: false,
      sentAt: new Date(parseInt(message.timestamp) * 1000),
      createdAt: new Date()
    };

    await webhookService.processIncomingMessage(
      account.id,
      messageData,
      'whatsapp',
      { message, metadata }
    );
  }

  private async processFacebookMessage(messagingEvent: any): Promise<void> {
    const senderId = messagingEvent.sender.id;
    const recipientId = messagingEvent.recipient.id;
    const message = messagingEvent.message;

    if (!message) return;

    // Find connected account (recipient is the page)
    const account = await this.findAccountByPlatformUserId('facebook', recipientId);
    
    if (!account) {
      console.warn(`No connected account found for Facebook page ${recipientId}`);
      return;
    }

    // Transform to our message format
    const messageData: Message = {
      id: '',
      conversationId: senderId,
      platformMessageId: message.mid,
      senderId: senderId,
      senderName: 'Facebook User',
      content: message.text || '',
      messageType: message.attachments?.[0]?.type || 'text',
      mediaUrl: message.attachments?.[0]?.payload?.url,
      isOutgoing: false,
      isRead: false,
      sentAt: new Date(messagingEvent.timestamp),
      createdAt: new Date()
    };

    await webhookService.processIncomingMessage(
      account.id,
      messageData,
      'facebook',
      { messagingEvent }
    );
  }

  private async processTeamsMessage(resourceData: any): Promise<void> {
    const chatId = resourceData.chatId;
    const senderId = resourceData.from?.user?.id;
    
    if (!senderId) return;

    // Find connected account
    // For Teams, we need to find by the user's Teams ID
    const account = await this.findAccountByPlatformUserId('teams', senderId);
    
    if (!account) {
      console.warn(`No connected account found for Teams user ${senderId}`);
      return;
    }

    // Transform to our message format
    const messageData: Message = {
      id: '',
      conversationId: chatId,
      platformMessageId: resourceData.id,
      senderId: senderId,
      senderName: resourceData.from?.user?.displayName || 'Teams User',
      content: resourceData.body?.content || '',
      messageType: 'text',
      isOutgoing: false,
      isRead: false,
      sentAt: new Date(resourceData.createdDateTime),
      createdAt: new Date()
    };

    await webhookService.processIncomingMessage(
      account.id,
      messageData,
      'teams',
      { resourceData }
    );
  }
}

// Export singleton instance
export const webhookController = new WebhookController();
